/* Automatically generated by Amaranth 0.5.4. Do not edit. */
/* Generated by Yosys 0.48+51 (git sha1 41e4aa8f0, g++ 14.2.0-8 -fPIC -O3) */

module top(clk125_0__n, clk125_0__p);
  reg \$auto$verilog_backend.cc:2348:dump_module$1  = 0;
  wire [16:0] \$1 ;
  wire [16:0] \$2 ;
  wire [17:0] \$3 ;
  reg [15:0] \$4 ;
  reg [7:0] \$5 ;
  reg [15:0] \$6 ;
  reg [15:0] \$7 ;
  reg \$8 ;
  wire begin_glitches;
  wire \begin_glitches$12 ;
  wire clk;
  input clk125_0__n;
  wire clk125_0__n;
  input clk125_0__p;
  wire clk125_0__p;
  reg [15:0] cnt = 16'h0000;
  wire end_glitches;
  wire \end_glitches$14 ;
  wire [7:0] median;
  wire [7:0] \median$16 ;
  wire mult_a;
  wire mult_b;
  reg new_phase = 1'h0;
  reg [15:0] phase = 16'h0000;
  wire sig_in;
  wire \sig_in$4 ;
  reg [15:0] t = 16'h0000;
  reg [7:0] ta = 8'h00;
  assign \$2  = t - ta;
  assign \$3  = $signed(\$2 ) + $signed({ 1'h0, \median$16  });
  always @(posedge clk)
    cnt <= \$4 ;
  always @(posedge clk)
    ta <= \$5 ;
  always @(posedge clk)
    t <= \$6 ;
  always @(posedge clk)
    phase <= \$7 ;
  always @(posedge clk)
    new_phase <= \$8 ;
  assign \$1  = cnt + 1'h1;
  \top.cd_sync  cd_sync (
    .clk(clk),
    .clk125_0__n(clk125_0__n),
    .clk125_0__p(clk125_0__p)
  );
  \top.deglitch_a  deglitch_a (
    .begin_glitches(begin_glitches),
    .clk(clk),
    .end_glitches(end_glitches),
    .median(median),
    .sig_in(sig_in)
  );
  \top.deglitch_b  deglitch_b (
    .begin_glitches(\begin_glitches$12 ),
    .clk(clk),
    .end_glitches(\end_glitches$14 ),
    .median(\median$16 ),
    .sig_in(\sig_in$4 )
  );
  FDRE ffa (
    .C(clk),
    .CE(1'h1),
    .D(1'h0),
    .Q(sig_in),
    .R(1'h0)
  );
  FDRE ffb (
    .C(clk),
    .CE(1'h1),
    .D(1'h0),
    .Q(\sig_in$4 ),
    .R(1'h0)
  );
  always @* begin
    if (\$auto$verilog_backend.cc:2348:dump_module$1 ) begin end
    \$4  = \$1 [15:0];
    if (begin_glitches) begin
      \$4  = 16'h0000;
    end
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2348:dump_module$1 ) begin end
    \$5  = ta;
    if (end_glitches) begin
      \$5  = median;
    end
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2348:dump_module$1 ) begin end
    \$6  = t;
    if (\begin_glitches$12 ) begin
      \$6  = cnt;
    end
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2348:dump_module$1 ) begin end
    \$7  = phase;
    if (\end_glitches$14 ) begin
      \$7  = \$3 [15:0];
    end
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2348:dump_module$1 ) begin end
    \$8  = new_phase;
    if (\end_glitches$14 ) begin
      \$8  = 1'h1;
    end
    if (new_phase) begin
      \$8  = 1'h0;
    end
  end
  assign mult_a = sig_in;
  assign mult_b = \sig_in$4 ;
endmodule

module \top.cd_sync (clk125_0__p, clk125_0__n, clk);
  output clk;
  wire clk;
  input clk125_0__n;
  wire clk125_0__n;
  input clk125_0__p;
  wire clk125_0__p;
  wire i;
  wire ready;
  STARTUPE2 \U$1  (
    .EOS(ready)
  );
  BUFGCTRL #(
    .SIM_DEVICE("7SERIES")
  ) \U$2  (
    .CE0(ready),
    .CE1(1'h0),
    .I0(i),
    .I1(1'h1),
    .IGNORE0(1'h0),
    .IGNORE1(1'h1),
    .O(clk),
    .S0(1'h1),
    .S1(1'h0)
  );
  \top.cd_sync.clk_buf  clk_buf (
    .clk125_0__n(clk125_0__n),
    .clk125_0__p(clk125_0__p),
    .i(i)
  );
endmodule

module \top.cd_sync.clk_buf (clk125_0__p, clk125_0__n, i);
  input clk125_0__n;
  wire clk125_0__n;
  input clk125_0__p;
  wire clk125_0__p;
  output i;
  wire i;
  wire \i$1 ;
  \top.cd_sync.clk_buf.buf  \buf  (
    .clk125_0__n(clk125_0__n),
    .clk125_0__p(clk125_0__p),
    .i(\i$1 )
  );
  assign i = \i$1 ;
endmodule

module \top.cd_sync.clk_buf.buf (clk125_0__p, clk125_0__n, i);
  input clk125_0__n;
  wire clk125_0__n;
  input clk125_0__p;
  wire clk125_0__p;
  output i;
  wire i;
  IBUFDS buf0 (
    .I(clk125_0__p),
    .IB(clk125_0__n),
    .O(i)
  );
endmodule

module \top.deglitch_a (clk, begin_glitches, end_glitches, median, sig_in);
  reg \$auto$verilog_backend.cc:2348:dump_module$2  = 0;
  wire \$1 ;
  wire \$2 ;
  wire \$3 ;
  wire \$4 ;
  wire \$5 ;
  wire \$6 ;
  wire \$7 ;
  wire \$8 ;
  reg [1:0] \$9 ;
  output begin_glitches;
  reg begin_glitches;
  reg [1:0] \buf  = 2'h0;
  input clk;
  wire clk;
  output end_glitches;
  reg end_glitches;
  reg [1:0] fsm_state = 2'h0;
  reg inc;
  output [7:0] median;
  wire [7:0] median;
  wire [7:0] \reg ;
  reg rst;
  reg [99:0] shift_reg = 100'h0000000000000000000000000;
  input sig_in;
  wire sig_in;
  assign \$1  = | shift_reg;
  assign \$2  = ~ \$1 ;
  assign \$3  = & shift_reg;
  assign \$4  = ~ \buf [0];
  assign \$5  = & shift_reg;
  assign \$6  = ! fsm_state;
  assign \$7  = fsm_state == 1'h1;
  assign \$8  = fsm_state == 2'h2;
  always @(posedge clk)
    \buf  <= { sig_in, \buf [1] };
  always @(posedge clk)
    shift_reg <= { \buf [0], shift_reg[99:1] };
  always @(posedge clk)
    fsm_state <= \$9 ;
  \top.deglitch_a.cnt  cnt (
    .clk(clk),
    .inc(inc),
    .\reg (median),
    .rst(rst)
  );
  always @* begin
    if (\$auto$verilog_backend.cc:2348:dump_module$2 ) begin end
    \$9  = fsm_state;
    casez (fsm_state)
      2'h0:
          if (\$2 ) begin
            \$9  = 2'h1;
          end
      2'h1:
          if (\buf [0]) begin
            \$9  = 2'h2;
          end
      2'h2:
          if (\$3 ) begin
            \$9  = 2'h0;
          end
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2348:dump_module$2 ) begin end
    rst = 1'h0;
    casez (fsm_state)
      2'h0:
          /* empty */;
      2'h1:
          if (\buf [0]) begin
            rst = 1'h1;
          end
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2348:dump_module$2 ) begin end
    begin_glitches = 1'h0;
    casez (fsm_state)
      2'h0:
          /* empty */;
      2'h1:
          if (\buf [0]) begin
            begin_glitches = 1'h1;
          end
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2348:dump_module$2 ) begin end
    inc = 1'h0;
    casez (fsm_state)
      2'h0:
          /* empty */;
      2'h1:
          /* empty */;
      2'h2:
          if (\$4 ) begin
            inc = 1'h1;
          end
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2348:dump_module$2 ) begin end
    end_glitches = 1'h0;
    casez (fsm_state)
      2'h0:
          /* empty */;
      2'h1:
          /* empty */;
      2'h2:
          if (\$5 ) begin
            end_glitches = 1'h1;
          end
    endcase
  end
  assign \reg  = median;
endmodule

module \top.deglitch_a.cnt (rst, inc, \reg , clk);
  reg \$auto$verilog_backend.cc:2348:dump_module$3  = 0;
  wire \$1 ;
  reg [1:0] \$10 ;
  wire [4:0] \$2 ;
  wire \$3 ;
  wire \$4 ;
  wire [4:0] \$5 ;
  wire \$6 ;
  wire \$7 ;
  wire [1:0] \$8 ;
  reg [7:0] \$9 ;
  input clk;
  wire clk;
  input inc;
  wire inc;
  reg [1:0] ith_chunk_overflow = 2'h0;
  output [7:0] \reg ;
  reg [7:0] \reg  = 8'h00;
  input rst;
  wire rst;
  assign \$2  = \reg [3:0] + 1'h1;
  assign \$3  = \reg [3:0] == 4'he;
  assign \$5  = \reg [7:4] + 1'h1;
  assign \$6  = \reg [7:4] == 4'he;
  assign \$7  = & ith_chunk_overflow;
  always @(posedge clk)
    \reg  <= \$9 ;
  always @(posedge clk)
    ith_chunk_overflow <= \$10 ;
  always @* begin
    if (\$auto$verilog_backend.cc:2348:dump_module$3 ) begin end
    \$9  = \reg ;
    if (inc) begin
      if (\$1 ) begin
        \$9 [3:0] = \$2 [3:0];
      end
      if (\$4 ) begin
        \$9 [7:4] = \$5 [3:0];
      end
    end
    if (rst) begin
      \$9  = 8'h00;
    end
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2348:dump_module$3 ) begin end
    \$10  = ith_chunk_overflow;
    if (inc) begin
      if (\$1 ) begin
        \$10 [0] = \$3 ;
      end
      if (\$4 ) begin
        \$10 [1] = \$6 ;
      end
    end
    if (rst) begin
      \$10  = 2'h0;
    end
  end
  assign \$1  = 1'h1;
  assign \$4  = ith_chunk_overflow[0];
  assign \$8  = 2'h1;
endmodule

module \top.deglitch_b (clk, begin_glitches, end_glitches, median, sig_in);
  reg \$auto$verilog_backend.cc:2348:dump_module$4  = 0;
  wire \$1 ;
  wire \$2 ;
  wire \$3 ;
  wire \$4 ;
  wire \$5 ;
  wire \$6 ;
  wire \$7 ;
  wire \$8 ;
  reg [1:0] \$9 ;
  output begin_glitches;
  reg begin_glitches;
  reg [1:0] \buf  = 2'h0;
  input clk;
  wire clk;
  output end_glitches;
  reg end_glitches;
  reg [1:0] fsm_state = 2'h0;
  reg inc;
  output [7:0] median;
  wire [7:0] median;
  wire [7:0] \reg ;
  reg rst;
  reg [99:0] shift_reg = 100'h0000000000000000000000000;
  input sig_in;
  wire sig_in;
  assign \$1  = | shift_reg;
  assign \$2  = ~ \$1 ;
  assign \$3  = & shift_reg;
  assign \$4  = ~ \buf [0];
  assign \$5  = & shift_reg;
  assign \$6  = ! fsm_state;
  assign \$7  = fsm_state == 1'h1;
  assign \$8  = fsm_state == 2'h2;
  always @(posedge clk)
    \buf  <= { sig_in, \buf [1] };
  always @(posedge clk)
    shift_reg <= { \buf [0], shift_reg[99:1] };
  always @(posedge clk)
    fsm_state <= \$9 ;
  \top.deglitch_b.cnt  cnt (
    .clk(clk),
    .inc(inc),
    .\reg (median),
    .rst(rst)
  );
  always @* begin
    if (\$auto$verilog_backend.cc:2348:dump_module$4 ) begin end
    \$9  = fsm_state;
    casez (fsm_state)
      2'h0:
          if (\$2 ) begin
            \$9  = 2'h1;
          end
      2'h1:
          if (\buf [0]) begin
            \$9  = 2'h2;
          end
      2'h2:
          if (\$3 ) begin
            \$9  = 2'h0;
          end
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2348:dump_module$4 ) begin end
    rst = 1'h0;
    casez (fsm_state)
      2'h0:
          /* empty */;
      2'h1:
          if (\buf [0]) begin
            rst = 1'h1;
          end
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2348:dump_module$4 ) begin end
    begin_glitches = 1'h0;
    casez (fsm_state)
      2'h0:
          /* empty */;
      2'h1:
          if (\buf [0]) begin
            begin_glitches = 1'h1;
          end
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2348:dump_module$4 ) begin end
    inc = 1'h0;
    casez (fsm_state)
      2'h0:
          /* empty */;
      2'h1:
          /* empty */;
      2'h2:
          if (\$4 ) begin
            inc = 1'h1;
          end
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2348:dump_module$4 ) begin end
    end_glitches = 1'h0;
    casez (fsm_state)
      2'h0:
          /* empty */;
      2'h1:
          /* empty */;
      2'h2:
          if (\$5 ) begin
            end_glitches = 1'h1;
          end
    endcase
  end
  assign \reg  = median;
endmodule

module \top.deglitch_b.cnt (rst, inc, \reg , clk);
  reg \$auto$verilog_backend.cc:2348:dump_module$5  = 0;
  wire \$1 ;
  reg [1:0] \$10 ;
  wire [4:0] \$2 ;
  wire \$3 ;
  wire \$4 ;
  wire [4:0] \$5 ;
  wire \$6 ;
  wire \$7 ;
  wire [1:0] \$8 ;
  reg [7:0] \$9 ;
  input clk;
  wire clk;
  input inc;
  wire inc;
  reg [1:0] ith_chunk_overflow = 2'h0;
  output [7:0] \reg ;
  reg [7:0] \reg  = 8'h00;
  input rst;
  wire rst;
  assign \$2  = \reg [3:0] + 1'h1;
  assign \$3  = \reg [3:0] == 4'he;
  assign \$5  = \reg [7:4] + 1'h1;
  assign \$6  = \reg [7:4] == 4'he;
  assign \$7  = & ith_chunk_overflow;
  always @(posedge clk)
    \reg  <= \$9 ;
  always @(posedge clk)
    ith_chunk_overflow <= \$10 ;
  always @* begin
    if (\$auto$verilog_backend.cc:2348:dump_module$5 ) begin end
    \$9  = \reg ;
    if (inc) begin
      if (\$1 ) begin
        \$9 [3:0] = \$2 [3:0];
      end
      if (\$4 ) begin
        \$9 [7:4] = \$5 [3:0];
      end
    end
    if (rst) begin
      \$9  = 8'h00;
    end
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2348:dump_module$5 ) begin end
    \$10  = ith_chunk_overflow;
    if (inc) begin
      if (\$1 ) begin
        \$10 [0] = \$3 ;
      end
      if (\$4 ) begin
        \$10 [1] = \$6 ;
      end
    end
    if (rst) begin
      \$10  = 2'h0;
    end
  end
  assign \$1  = 1'h1;
  assign \$4  = ith_chunk_overflow[0];
  assign \$8  = 2'h1;
endmodule
